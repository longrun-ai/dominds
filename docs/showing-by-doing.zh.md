# 做给祂看（Showing-by-Doing）：把诉请机制变成“体感”

英文版：[English](./showing-by-doing.md)

## 摘要

Dominds 的诉请（Tellask，`!?@...`）与扪心自问（FBR，`!?@self`）并不是“写在系统提示里的约定”，而是**后端真实可驱动、可执行、可回传、可持久化**的机制。

问题在于：即使系统提示把诉请机制写得再细，大多数基础模型也并未在“真的可以随时拉一个队友去跑 shell 命令并把结果带回来”的世界里被训练过，因此容易把这些提示当成“说说而已 / 仅供参考”。这会直接削弱诉请与 FBR 的可用性。

因此引入 **“做给祂看”**：在一个对话创建之初，运行一段极短、极拟真的“真实诉请 + 真实 FBR”往返，让智能体产生明确的体感：

- 诉请是真的，会被执行
- 工具输出是真的，会被带回并写入对话记录
- `!?@self` FBR 也是真的，会作为支线对话产出报告并回传

体感建立后，系统提示可以**大幅简化**：只保留“短而准确”的契约说明即可，把“这在本环境里真实可用”的可信度交给做给祂看来完成。

相关文档：

- 诉请机制与子对话：`dominds/docs/dialog-system.md`
- 术语约定（主线/支线；诉请方/应答方）：`dominds/docs/dominds-terminology.md`
- FBR（`!?@self`）：`dominds/docs/fbr.md`
- 工作语言 vs UI 语言：`dominds/docs/i18n.md`

---

## 目标

- 在对话一开始就建立“诉请/回传/持久化都是真的”的信任。
- 在对话一开始就跑通一次 `!?@self` 的 FBR 回路。
- 过程足够小、可控、低风险（默认只执行 `uname -a`）。
- 记录从多角度都高度拟真：后端存档 + 前端可见的对话转录。

## 非目标

- 不在创建对话时执行任意用户输入的命令。
- 不收集敏感信息（默认只采集最小的 OS/Kernel 识别信息）。
- 不替代系统提示/设计文档：这是“体感补强”，不是完整规范的主载体。

---

## 概念（用户视角）

- **主线对话**：用户与主要智能体交互的那条线。
- **支线对话**：由诉请 / FBR 触发的临时工作线，产出结果回传主线。
- **诉请（Tellask）**：以 `!?@<memberId> ...` 向队友/对话发起的结构化请求。
- **Shell 专家（shell specialist）**：被允许执行 shell 命令并回传结果的队友（由 `shell_specialists` 配置指定）。
- **FBR（扪心自问）**：以 `!?@self` 触发的“无工具支线推理”，产出报告回传主线。

---

## 运行流程（对话创建时）

做给祂看发生在**第一条用户消息被处理之前**（可视为一个 Prelude / 序幕），除非用户在创建对话时明确选择跳过。

### 1）选择执行路径

1. 如果 team 配置里存在 `shell_specialists`，选择一个 shell 专家（建议确定性选择：列表第一个）。
2. 否则，由 **Dominds 运行时**直接执行基线命令（不通过智能体工具）。

补充：team 配置校验一般会要求——只要有队友拥有 shell 工具，就必须配置非空的 `shell_specialists`；同时，非 shell 专家不应持有 shell 工具。因此“没有配置 `shell_specialists`”通常意味着“对用户可见的队友都没有 shell 工具可用”。

基线命令（默认）：

- `uname -a`

`uname -a` 失败时（例如非 POSIX 环境），可以改用平台等价命令；但默认肌肉记忆路径保留 `uname -a`，因为它低风险、快、且信息量刚好够用。

### 2）真实队友诉请：让 shell 专家执行 `uname -a`

若存在 shell 专家，则主线智能体（诉请方）以**工作语言**（server-wide，见 `dominds/docs/i18n.md`）向 shell 专家（应答方）发起真实诉请，要求：

- 执行 `uname -a`
- 原样返回输出
- 若命令不可用，返回错误信息，并给出替代命令建议

结果必须以正常对话转录的方式落盘并展示，至少清晰体现：

- 诉请的 headline + body
- shell 专家实际执行了命令
- 返回的原始输出

最小配置示例：

```yaml
# .minds/team.yaml
shell_specialists:
  - cmdr
```

### 3）真实 FBR：基于环境信息做一次“扪心自问”

拿到环境快照（来自 shell 专家或直接运行）后，主线智能体触发一次 `!?@self` FBR，并在 FBR 的诉请正文里带上：

- `uname -a` 的完整输出
- 主线可用工具的假设（例如“主线可能有 `fs`/`os`/`mem`；但 FBR 你没有任何工具”）
- 问题：在这个环境里要注意什么？优先用哪些命令行工具，为什么？

FBR 产出应尽量短而可复用，典型包括：

- 环境判断（OS 家族、内核、是否容器/VM 线索）
- 注意事项（坑点清单）
- “优先工具/命令” shortlist（例如 `rg`、`sed`、`jq`、`tar`、`ps`、`lsof` 等，视环境而定）

### 4）把结果收敛成“环境速记”

主线智能体在主线对话里追加一条短总结（Environment Quickstart），让关键信息显性化、可检索。

---

## 降级策略

- **未配置 `shell_specialists`**：由 Dominds 运行时直接执行 `uname -a`，然后进入 FBR。
- **shell 专家失败/超时**：记录失败原因，由 Dominds 运行时直接执行 `uname -a`，继续进入 FBR。
- **`uname` 不存在/执行失败**：跳过命令执行，直接让 FBR 以“环境未知”输出：缺什么信息、为什么关键、后续如何补齐。

---

## 持久化、缓存与复用

### 1）记录必须“像真的一样”

做给祂看的每一步都必须作为标准对话记录落盘（消息 + 事件），并在 WebUI 中可见：

- 可跨重启（遵循常规对话持久化）
- 可 debug（日志/存储都有迹可循）
- 前端可查看转录（建议 UI 上做一个可折叠 Prelude 区域）

### 2）仅进程内缓存（按智能体维度）

为了避免每次新对话都重复跑 `uname -a` + FBR，后端进程可以维护一个**进程内缓存**（重启失效），按（至少）主线智能体 id 做 key。

缓存内容建议包含：

- 完整转录（诉请 + shell 输出 + FBR + 速记）
- 一份更短的 distilled “环境速记”（用于注入上下文）
- 时间戳 + 版本号（未来 schema 变化用）

复用策略：

- 若命中缓存，新对话可以直接复用首次的转录与速记，不再重复执行。
- 复用的记录在新对话里仍应可见，并清楚标记“来自缓存复用”。

### 3）跨 `clear_mind` 携带

每次 `clear_mind` 进入下一程时，不要依赖 reminder 来承载这件事。

改为：在每一程对话的上下文里，注入一段小而稳定的 **course prefix**（可理解为“历史消息区最开头的几条 msg”），内容是从首次做给祂看中提炼出的压缩转录（shell 快照 + FBR 摘要 + 环境速记）。这样智能体能持续保留“体感”和环境约束，而无需重复执行 Prelude，也不必每次把整段长转录重新塞进上下文。

---

## WebUI 需求

### 展示

- 做给祂看应以真实对话转录展示，用户可展开查看细节。
- 建议在对话顶部提供一个可折叠 Prelude 区域，并带上清晰标签：
  - “队友诉请（shell）”
  - “FBR（`!?@self`）”
  - “环境速记（Environment Quickstart）”

### 创建对话时可选择跳过（opt-out）

创建对话框上提供明确开关，例如：

- Checkbox：“跳过做给祂看（不执行环境序幕）”

若选择跳过，则不执行任何 Prelude 行为，也不生成 Prelude 转录。

---

## 安全注意事项

- 默认只执行 `uname -a`（低风险、只读、快）。
- Prelude 禁止任何会改写文件/网络/系统状态的操作。
- 由于 Prelude 默认用户可见，严禁输出密钥/敏感信息。
