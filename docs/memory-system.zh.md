# Memory System / 记忆系统（Agent User View / 智能体用户视角）

Dominds 围绕**有意的、分层的记忆**设计。

目标很简单：

- 保持**聊天历史**可丢弃。
- 保持一组小的**高价值、精炼的产物**，它们可以在 `clear_mind` 中存活并推动可靠的进展。

本文档定义了这些层次的理想使用契约，以及支持它的预期产品行为。

## 读者 / Audience

本文档面向**智能体使用者**。

它有意：

- 避免内部存储路径和其他实现细节；
- 专注于**你可以实际使用的工具**以及这些工具所暗示的行为契约。

相关词汇指南：`dominds/docs/dominds-terminology.md`。

## 目录 / Table of Contents

- 层级（存在什么，用于什么）
- 卫生循环（如何日常工作）
- 预期的运行时行为（你可以依赖什么）
- 实际示例

## 层级（存在什么，用于什么）

### 1) 任务文档（Taskdoc，`*.tsk/`）— 规范任务契约

**目的**：任务的单一真实来源。

- `goals`：完成时必须为真的内容。
- `constraints`：硬规则、安全约束、风格约束。
- `progress`：精炼的状态：什么改变了、关键决策、下一步。

**属性**：

- 跨对话、跨对话新过程开启的持久化。
- 始终应该小到可以每次 LLM 生成都包含在上下文中。
- 仅通过 `change_mind({ selector, category?, content })` 编辑（仅在主对话中可用；子对话必须要求任务文档维护者智能体更新——维护者 @id 在注入的任务文档状态块中打印）。
- 额外的任务文档章节（非自动注入）可以通过 `recall_taskdoc({ category, selector })` 读取。
- **在队友之间共享**（在同一 rtws（运行时工作区）/任务文档内）：每个队友/子对话看到相同的任务文档（`goals` / `constraints` / `progress`）。

**共享编辑规则（重要）**：

- 将 `goals` / `constraints` / `progress` 视为**团队共享部分**（不是个人草稿本）。
- `change_mind` 替换**整个目标部分**。因此：
  - 始终从当前部分内容开始；
  - 在保留意义的同时仔细合并/追加或压缩；
  - **不要**覆盖或删除其他贡献者的条目。
- 任务文档在每次生成时内联注入到智能体上下文中。当你需要审查它时，依赖注入的任务文档内容（本轮次的最新内容），而不是尝试通过通用文件工具读取 `*.tsk/` 下的文件（它们被禁止且会被拒绝）。
- 当你添加/维护条目时，包含清晰的负责人标记，例如：
  - `- [owner:@ux] …` 或 `- [owner:@fullstack] …`
  - 或一个小负责人块，如 `### @ux` 及其下方的要点。

**如何使用 `progress`（重要）**：

- 将 `progress` 视为**共享公告板**：仅精炼的里程碑快照（关键决策/当前状态/下一步）。
- **不要**将 `progress` 用作原始工作日志。高频细节属于提醒项（工作集）。

**反模式**：

- 将 `progress` 变成草稿本或原始日志。
- 在任务文档中存储长的工具输出。
- 覆盖任何任务文档部分并删除其他贡献者的条目。

### 2) 提醒项（Reminders）— 精炼的工作集（工作日志）

**目的**：智能体主动维护的一小部分"宝贵"上下文项目。

提醒项是**值得支付提示 tokens 的细节**的最佳位置，因为：

- 它们在 `clear_mind` 中持久化。
- 它们通过 `update_reminder` / `delete_reminder` 被智能体有意地**精炼**。
- 它们总是注入到下一次生成中，因此它们实际上会影响行为。

**两种类型**：

- **非拥有的提醒项（智能体管理）**：你的主要工作日志/工作集。
- **拥有的提醒项（系统管理）**：生命周期由 `ReminderOwner` 拥有（自动更新/自动删除）。将其视为信号；不要手动删除。

**理想使用规则**：

- 保持提醒项**小**（通常总共 1-3 项）。
- 偏好**原地更新**（`update_reminder`）而不是创建许多单独的提醒项。
- 每个提醒项必须证明其 token 成本：如果它不再改变决策，**删除它**。

**范围说明**：

- 提醒项是**对话局部的**（这个对话/智能体的工作集）。它们不是团队范围的公告板。

**注入语义（重要）**：

- 提醒项**在每次生成时注入到 LLM 上下文中**。
- 在当前代码中，提醒项主要渲染为**`role=user` 环境指导**，位于最后一条用户消息附近。这是有意为之，为了突出性：提醒项应该很难被忽略。
- 提醒项注入**不会持久化到对话历史/事件中**（它只是上下文）。

**单个"工作日志提醒项"的推荐结构**：

- 最后更新：时间戳（人类可读）
- 我们现在在做什么：1-3 个要点
- 冻结的关键决策：1-5 个要点
- 下一步：3-8 个可操作的要点
- "不要忘记"：1-3 个高风险笔记

### 3) 个人记忆 — 稳定的个人习惯 + 责任索引

**目的**：特定智能体人格的持久"我如何工作"知识，加上一个紧凑的责任领域 **rtws 索引**，这样你就可以在不重新读取文件的情况下采取行动。

用于：

- 个人约定，
- 启发式，
- 稳定偏好。
- **责任领域 rtws 索引**：你拥有的精确文件路径（文档和/或代码），加上最小的关键事实（入口点、关键符号、局部契约），让你可以直接提出和应用编辑而不必重新读取 rtws。

**不要**用于：

- 每任务状态，
- 应该共享的每 rtws 事实，
- 瞬态工具输出。

**准确性契约（重要）**：

- 将你的责任领域 rtws 索引视为你的范围内的精炼"单一真实来源"。
- 每当你更改相关文件或检测到过时/冲突时，立即更新个人记忆（`replace_memory`），以便它跟踪最新的 rtws 事实。

工具：

- `add_memory`、`replace_memory`、`drop_memory`、`clear_memory`。

### 4) 团队记忆 — 稳定的共享约定

**目的**：应该在整个团队和所有对话中共享的持久知识。

用于：

- 仓库约定，
- 架构决策，
- "我们如何在这里运行测试"，
- 跨智能体契约。

工具：

- `add_team_memory`、`replace_team_memory`、`drop_team_memory`、`clear_team_memory`。

### 5) 工具调用历史/聊天消息 — 可丢弃且不可靠

**目的**：短暂的工作缓冲区。

工具调用结果和长的文件读取可能很大。它们对于决定下一步很有用，但它们不是好的长期记忆基质。

**规则**：如果你以后需要它，**提炼它**：

- 任务文档 `progress`（决策 + 下一步），和/或
- 一个提醒项细节（精炼的），和/或
- 团队记忆（仅当它真正稳定），和/或
- 个人记忆（习惯/偏好，以及你保持准确的责任领域 rtws 索引）。

永远不要依赖"我之前读过它"作为持久假设。

## 卫生循环（如何日常工作）

### 默认循环

1. 根据需要使用工具调用进行工作。
2. 提炼：
   - 用决策和下一步更新任务文档 `progress`；
   - 用任何关键细节更新一个小提醒工作日志。
3. `clear_mind` 以删除嘈杂的聊天/工具历史。

### 当上下文健康变为黄色/红色时

- 黄色（警告）：停止添加新的输入；现在开始提炼。
- 红色（危险）：视为硬性停止：立即提炼；不要先继续实现。

在黄色/红色时，正确的行为不是"继续直到它崩溃"。正确的行为是：

- 压缩你需要的内容到任务文档 + 提醒项，
- 然后清除。

## 预期的运行时行为（你可以依赖什么）

为了使上述可靠，Dominds 应该：

- 将提醒项视为**一等公民工作集**，而不是麻烦。
- 鼓励**原地更新**提醒项维护，并劝阻提醒项垃圾信息。
- 使拥有的提醒项明确"系统管理"，而不建议手动删除。
- 使 `clear_mind` 在心理上廉价：
  - 明确说明任务文档和提醒项被保留，
  - 明确指导提炼 → 清除序列。

## 实际示例

### 示例：巨大的工具输出

- 只将决策 + 下一步放入任务文档 `progress`。
- 将基本摘录（不是整个转储）放入提醒工作日志。
- 然后 `clear_mind`。

### 示例：稳定的仓库约定

- 将其放入团队记忆，而不是提醒项。

### 示例：我的个人工作流程偏好

- 将其放入个人记忆。
